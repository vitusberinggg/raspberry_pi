
# --- Imports ---

import Rpi.GPIO as GPIO # Imports the RPi.GPIO library which allows control of the GPIO pins on a Raspberry Pi
import time
import random
from luma.core.interface.serial import i2c # 
from luma.oled.device import ssd1306 # 
from luma.core.render import canvas #
from PIL import ImageFont # Imports ImageFont from PIL
from pygame import mixer # Imports the mixer module from the pygame library for audio playback

# --- Definitions ---

delay_interval = [2, 10]

player_pins = {
    1: {'GREEN_LED': 17, 'RED_LED': 22, 'BUTTON': 27},
    2: {'GREEN_LED': 24, 'RED_LED': 5, 'BUTTON': 23},
    3: {'GREEN_LED': 6, 'RED_LED': 12, 'BUTTON': 25},
    4: {'GREEN_LED': 13, 'RED_LED': 16, 'BUTTON': 19}
}

players = list(player_pins.keys()) # Creates a list called "players" which holds the keys of the dictionary "player_pins" (e.g the players)
active_players = list(players) # Creates a list called "active_players" and set it's inital value to "players" (to make sure that no one is disqualified from start)
number_of_players = len(players) # Sets the number of players to the length of the list "players"

center_LED_pin = 

# --- GPIO setup ---

GPIO.setmode(GPIO.BCM) # Sets the pin numbering scheme to BCM (Broadcom) mode
GPIO.setwarnings(False) # Disables the warnings that the "RPi.GPIO" library might generate

for player in player_pins.values(): # Loops through the values in "player_pins"
    GPIO.setup(player['GREEN_LED'], GPIO.OUT) # Configures each player's green LED-pin as an output
    GPIO.setup(player['RED_LED'], GPIO.OUT) # Configures each player's red LED-pin as an output
    GPIO.setup(player['BUTTON'], GPIO.IN, pull_up_down = GPIO.PUD_DOWN) # Configures each players button as an input with a software pull-down resistor (ensures that the pin is at a stable low (0V) until the button is pressed, at which point the voltage goes high (3.3V) and the program can detect the press)

GPIO.setup(center_LED_pin, GPIO.OUT) # Configures the center LED-pin as an output

# --- Display setup ---

try: # Try to:
    serial = i2c(port = 1, address = 0x3c) # Establish a connection to the OLED display using the I2C communication protocol at address 0x3c on port 1
    device = ssd1306(serial) # Create an object called "device" that represents the OLED display
    display_font = ImageFont.truetype("DejaVuSansMono-Bold.ttf", 14) # Load a TrueType font for displaying text on the OLED display

except Exception as e: # If that doesn't work
    print(f"OLED display not found or could not be initialized: {e}") # Print an error message
    device = None # Set device to None

# --- Speaker setup ---

try: # Try to:
    mixer.init() # Initialize the audio mixer
    start_sound = mixer.Sound("start_sound.wav") # Load the sound file for the start sound
    win_sound = mixer.Sound("win_sound.wav") # Load the sound file for the win sound

except Exception as e: # If that doesn't work
    print(f"Could not initialize audio mixer or load sound files: {e}") # Print an error message
    start_sound = None # Set start_sound to None
    win_sound = None # Set win_sound to None

# --- Helper functions ---

def update_display(text_lines):

    """
    Updates the OLED display with a list of strings.

    Arguments:
        "text_lines":
    
    Returns:
        None
    
    """
    
    if device:

        with canvas(device) as draw:
            y = 0

            for line in text_lines:
                draw.text((0, y), line, font = display_font, fill = "white")
                y += 16

def play_sound(sound):

    """
    Plays given sound file.

    Arguments:
        "sound":
    
    Returns:
        None

    """

    if sound:
        sound.play()

def all_lights_off():

    """
    Turns off all lights.

    Arguments:
        None
    
    Returns:
        None

    """
    
    for player in player_pins.values(): # Go through each value in the dictionary "player_pins"
        GPIO.output(player['GREEN_LED'], GPIO.LOW) # Sets the green LED's value to "LOW" (which turns it off)
        GPIO.output(player['RED_LED'], GPIO.LOW) # Sets the red LED's value to "LOW" (which turns it off)

    GPIO.output(center_LED_pin, GPIO.LOW) # Sets the center LED's value to "LOW" (which turns it off)


def round_loop(active_players):

    """

    Handles a single round of the game.

    Arguments:
        "active_players":
    
    Returns:
        "reaction_times": Dictionary of reaction times for active players.

    """

    update_display(["Press all buttons", "to Start!"])
    
    while True: # Creates an infinite loop

        if all(GPIO.input(player_pins[player]['BUTTON']) == GPIO.HIGH for player in active_players): # If all active players are pressing their buttons:
            break # Break the loop

        time.sleep(0.1) # Sleep for 0.1 second (to prevent high CPU usage)

    update_display(["GET READY!"])

    all_lights_off()

    delay_time = random.uniform(*delay_interval) # Sets the variable "delay_time" to a random number in "delay_interval"

    time.sleep(1) # Sleep for 1 second

    # Early Press Detection Phase

    reaction_times = {} # Creates an empty dictionary called "reaction_times" to store the reaction times of each player

    for _ in range(int(delay_time * 10)): # Loop for the duration of the delay time in 0.1 second intervals

        for player in active_players: # For each active player

            if GPIO.input(player_pins[player]['BUTTON']) == GPIO.HIGH and player not in reaction_times: # If the player is pressing their button and is not already disqualified

                update_display([f"Player {player}", "EARLY PRESS!", "Disqualified"]) # Update the display to show that the player pressed early
                GPIO.output(player_pins[player]['RED_LED'], GPIO.HIGH) # Turn on the red LED for the player
                active_players.remove(player) # Remove the player from the list of active players
        
        time.sleep(0.1) # Sleep for 0.1 second
    
    # Reaction Phase

    update_display(["GO!"])
    play_sound(start_sound)
    GPIO.output(center_LED_pin, GPIO.HIGH)

    start_time = time.time()
    
    while len(reaction_times) < len(active_players): # While not all active players have reacted
        for player in active_players: # For each active player
            if player not in reaction_times: # If the player has not yet reacted
                if GPIO.input(player_pins[player]['BUTTON']) == GPIO.HIGH: # If the player is pressing their button
                    GPIO.output(player_pins[player]['GREEN_LED'], GPIO.HIGH) # Turn on the green LED for the player
                    reaction_time = (time.time() - start_time) * 1000 # Calculate the reaction time in milliseconds
                    reaction_times[player] = reaction_time # Store the reaction time in the dictionary
    
    return reaction_times

def main_tournament():

    """
    Manages the tournament.

    Arguments:
        None

    Returns:
        None
    
    """

    global active_players # Declares "active_players" as a global variable to modify it within the function
    active_players = list(players) # Resets the list of active players to include all players at the start of the tournament

    round_number = 1 # Initializes the round number

    while len(active_players) > 1: # While there is more than one active player

        update_display([f"Round {round_number}", "Players:", f"{active_players}"]) # Update the display to show the current round and active players
        time.sleep(3) # Sleep for 3 seconds

        reaction_times = round_loop(active_players) # Call the round_loop function and store the returned reaction times
        
        if not reaction_times: # If no players reacted (all disqualified)
            update_display(["NO WINNER"]) # Update the display to show "NO WINNER"
            break # Exit the loop

        sorted_players = sorted(reaction_times, key = reaction_times.get) # Sort the players by their reaction times

        for player in sorted_players: # For each player in the sorted list

            time_str = "DISQUALIFIED" if reaction_times[player] == float('inf') else f"{reaction_times[player]:.2f} ms" # Format the reaction time or mark as disqualified
            update_display([f"Player {player}", f"Time: {time_str}"]) # Update the display to show the player's reaction time
            time.sleep(2)

        slowest_player = sorted_players[-1] # The slowest player is the last in the sorted list
        active_players.remove(slowest_player) # Remove the slowest player from the list of active players
        
        update_display([f"Player {slowest_player}", "ELIMINATED"]) # Update the display to show that the slowest player is eliminated
        GPIO.output(player_pins[slowest_player]['RED_LED'], GPIO.HIGH) # Turn on the red LED for the slowest player

        round_number += 1

    if len(active_players) == 1: # If there is one active player left
        winner = active_players[0] # Set "winner" to the last remaining player
        update_display([f"WINNER:", "PLAYER {winner}"])
        play_sound(win_sound)
        GPIO.output(player_pins[winner]['GREEN_LED'], GPIO.HIGH)

    else:
        update_display(["NO WINNER"])
    
    time.sleep(5)