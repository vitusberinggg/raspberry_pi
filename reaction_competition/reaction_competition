
# --- Imports ---

import RPi.GPIO as GPIO # Imports the RPi.GPIO library which allows control of the GPIO pins on a Raspberry Pi
import time
import random
from RPLCD.i2c import CharLCD
from pygame import mixer # Imports the mixer module from the pygame library for audio playback

# --- Definitions ---

delay_interval = [3, 10]

player_pins = {
    "Red": {"GREEN_LED": 11, "RED_LED": 13, "BUTTON": 40},
    "Yellow": {"GREEN_LED": 15 , "RED_LED": 18, "BUTTON": 16},
    "Green": {"GREEN_LED": 29, "RED_LED": 32, "BUTTON": 31},
    "Blue": {"GREEN_LED": 33, "RED_LED": 37, "BUTTON": 36}
}

players = list(player_pins.keys()) # Creates a list called "players" which holds the keys of the dictionary "player_pins" (e.g the players)
active_players = list(players) # Creates a list called "active_players" and set it's inital value to "players" (to make sure that no one is disqualified from start)
number_of_players = len(players) # Sets the number of players to the length of the list "players"

center_LED_pin = 22

# --- GPIO setup ---

GPIO.setmode(GPIO.BOARD) # Sets the pin numbering scheme to BOARD mode
GPIO.setwarnings(False) # Disables the warnings that the "RPi.GPIO" library might generate

for player in player_pins.values(): # Loops through the values in "player_pins"
    GPIO.setup(player["GREEN_LED"], GPIO.OUT) # Configures each player's green LED-pin as an output
    GPIO.setup(player["RED_LED"], GPIO.OUT) # Configures each player's red LED-pin as an output
    GPIO.setup(player["BUTTON"], GPIO.IN, pull_up_down = GPIO.PUD_DOWN) # Configures each players button as an input with a software pull-down resistor (ensures that the pin is at a stable low (0V) until the button is pressed, at which point the voltage goes high (3.3V) and the program can detect the press)

GPIO.setup(center_LED_pin, GPIO.OUT) # Configures the center LED-pin as an output

# --- Display setup ---

try: # Try to:
    lcd = CharLCD(i2c_expander = "PCF8574", address = 0x27, port = 1,
                  cols = 16, rows = 2, dotsize = 8) # Initialize the LCD display with the specified parameters
    
    lcd.clear() # Clear the display

except Exception as e: # If that doesn't work
    print(f"Display not found or could not be initialized: {e}") # Print an error message
    lcd = None # Set lcd to None

# --- Speaker setup ---

try: # Try to:
    mixer.init() # Initialize the audio mixer
    start_sound = mixer.Sound("assets/sounds/start_sound.wav") # Load the sound file for the start sound
    win_sound = mixer.Sound("assets/sounds/win_sound.wav") # Load the sound file for the win sound

except Exception as e: # If that doesn't work
    print(f"Could not initialize audio mixer or load sound files: {e}") # Print an error message
    start_sound = None # Set start_sound to None
    win_sound = None # Set win_sound to None

# --- Helper functions ---

def update_display(line_1 = "", line_2 = ""):

    """
    Updates the LCD display with a list of strings.

    Arguments:
        "line_1":
        "line_2":
    
    Returns:
        None
    
    """

    if isinstance(line_1, (list, tuple)):
        lines = line_1
        line_1 = lines[0] if len(lines) > 0 else ""
        line_2 = lines[1] if len(lines) > 1 else ""

    if lcd:
        lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line_1).center(16))
        lcd.cursor_pos = (1, 0)
        lcd.write_string(str(line_2).center(16))

    else:
        print(f"[LCD]: {str(line_1)} | {str(line_2)}")

def play_sound(sound):

    """
    Plays given sound file.

    Arguments:
        "sound":
    
    Returns:
        None

    """

    if sound:
        sound.play()

def all_lights_off():

    """
    Turns off all lights.

    Arguments:
        None
    
    Returns:
        None

    """
    
    for player in player_pins.values(): # Go through each value in the dictionary "player_pins"
        GPIO.output(player["GREEN_LED"], GPIO.LOW) # Sets the green LED's value to "LOW" (which turns it off)
        GPIO.output(player["RED_LED"], GPIO.LOW) # Sets the red LED's value to "LOW" (which turns it off)

    GPIO.output(center_LED_pin, GPIO.LOW) # Sets the center LED's value to "LOW" (which turns it off)


def round_loop(active_players):

    """

    Handles a single round of the game.

    Arguments:
        "active_players":
    
    Returns:
        "reaction_times": Dictionary of reaction times for active players.

    """

    global round_number

    if len(active_players) == 4:

        last_update = 0
        step = 0
        messages = [
            ["Welcome to the", "reaction game!"],
            ["Press all", "buttons to start"]
]

        while True:
            if time.time() - last_update >= 3:
                update_display(messages[step % len(messages)])
                step += 1
                last_update = time.time()

            if all(GPIO.input(player_pins[player]["BUTTON"]) == GPIO.HIGH for player in active_players): # If all active players are pressing their buttons:
                break # Break the loop
            
            time.sleep(0.1)
    
    else:

        update_display(["Press all", "buttons to start"])

        while True: # Creates an infinite loop

            if all(GPIO.input(player_pins[player]["BUTTON"]) == GPIO.HIGH for player in active_players): # If all active players are pressing their buttons:
                break # Break the loop

            time.sleep(0.1) # Sleep for 0.1 second

    update_display(["Get ready..."])

    all_lights_off()

    delay_time = random.uniform(*delay_interval) # Sets the variable "delay_time" to a random number in "delay_interval"

    time.sleep(1) # Sleep for 1 second

    # Early Press Detection Phase

    reaction_times = {} # Creates an empty dictionary called "reaction_times" to store the reaction times of each player

    for _ in range(int(delay_time * 10)): # Loop for the duration of the delay time in 0.1 second intervals

        for player in active_players: # For each active player

            if GPIO.input(player_pins[player]["BUTTON"]) == GPIO.HIGH and player not in reaction_times: # If the player is pressing their button and is not already disqualified

                update_display([f"Player {player}", "EARLY PRESS!", "Disqualified"]) # Update the display to show that the player pressed early
                GPIO.output(player_pins[player]["RED_LED"], GPIO.HIGH) # Turn on the red LED for the player
                active_players.remove(player) # Remove the player from the list of active players
        
        time.sleep(0.1) # Sleep for 0.1 second
    
    # Reaction Phase

    update_display(["Go!"])
    play_sound(start_sound)
    GPIO.output(center_LED_pin, GPIO.HIGH)

    start_time = time.time()
    
    while len(reaction_times) < len(active_players): # While not all active players have reacted
        for player in active_players: # For each active player
            if player not in reaction_times: # If the player has not yet reacted
                if GPIO.input(player_pins[player]["BUTTON"]) == GPIO.HIGH: # If the player is pressing their button
                    GPIO.output(player_pins[player]["GREEN_LED"], GPIO.HIGH) # Turn on the green LED for the player
                    reaction_time = round((time.time() - start_time) * 1000) # Calculate the reaction time in milliseconds
                    reaction_times[player] = reaction_time # Store the reaction time in the dictionary
    
    return reaction_times

def main_tournament():

    """
    Manages the tournament.

    Arguments:
        None

    Returns:
        None
    
    """

    global active_players # Declares "active_players" as a global variable to modify it within the function
    active_players = list(players) # Resets the list of active players to include all players at the start of the tournament

    round_number = 1 # Initializes the round number

    while len(active_players) > 1: # While there is more than one active player

        if len(active_players) < 4:
            update_display([f"Round {round_number}", f"{len(active_players)} players left!"]) # Update the display to show the current round and active players
            time.sleep(3) # Sleep for 3 seconds

        reaction_times = round_loop(active_players) # Call the round_loop function and store the returned reaction times
        
        if not reaction_times: # If no players reacted (all disqualified)
            update_display(["NO WINNER"]) # Update the display to show "NO WINNER"
            break # Exit the loop

        sorted_players = sorted(reaction_times, key = reaction_times.get) # Sort the players by their reaction times

        for player in sorted_players: # For each player in the sorted list

            if reaction_times[player] == float("inf"):
                time_string = "Disqualified"
            
            else:
                time_string = f"{reaction_times[player]:.2f} ms"

            update_display([f"Player {player}", f"Time: {time_string}"]) # Update the display to show the player's reaction time

            time.sleep(2)

        slowest_player = sorted_players[-1] # The slowest player is the last in the sorted list
        active_players.remove(slowest_player) # Remove the slowest player from the list of active players
        
        update_display(f"Player {slowest_player}", "ELIMINATED") # Update the display to show that the slowest player is eliminated
        GPIO.output(player_pins[slowest_player]["RED_LED"], GPIO.HIGH) # Turn on the red LED for the slowest player

        round_number += 1

    if len(active_players) == 1: # If there is one active player left
        winner = active_players[0] # Set "winner" to the last remaining player
        update_display([f"WINNER:", "PLAYER {winner}"])
        play_sound(win_sound)
        GPIO.output(player_pins[winner]["GREEN_LED"], GPIO.HIGH)

    else:
        update_display(["No winner!"])
    
    time.sleep(5)

# --- Main execution ---

if __name__ == "__main__":

    try:
        while True:
            main_tournament()
            update_display("Game over!")
            time.sleep(3)
            update_display("Restarting...")
            time.sleep(3)

    except KeyboardInterrupt:
        print("\nGame interrupted. Exiting.")

    finally:
        all_lights_off()
        GPIO.cleanup()
        update_display("Goodbye!", "")
        time.sleep(5)
        update_display("")